!!!!!!!!!!!!!!!!!!New idea!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Prog name: Z34107 (zealot) v0.01
system call hijacking without touching the kernel via ptrace from userspace
each pid is monitored for system calls and then if readdir is found it's dirent struct
is modified as to not show the pid of one or more of the attacker's pids, namely
the backdoor itself. This userspace rootkit will essentially follow each instance of a fork  (via syscall tracing)
and add a new thread for monitoring the newly acquired pid. in this way, no process is without infection
the readdir() hack has a number of benefits, for one, virtually no program will be able to see the pid's proc entry
this includes lsof, ls, ps, top, monitoring software, netstat maybe even could be hit, more on this later. 
The truly lovely thing about this idea is a.) it doesn't touch kernel space b.) it's easily launched c.)
it's not blocked on 99.999999999% of all linux setups (probably even grsec)

Design considerations:
The design should be a thread model based on 1 thread per pid. whilst using shared memory for the HIDE_LIST
and possibly a do not monitor list, and others.

on an added note:
there can be a wrapper program to hide all the rootkit user's processes (ie: ./wrap bash) just by doing
the same method of following forks except that instead of editing the system calls it will simply add the
pids controled by the attacker to the HIDE_LIST which will essentially be shared memory amongst the monitoring
threads.

on an added note it may be advisable to have a ptrace(PTRACE_ATTACH, getpid()) wrapper program for the
rootkit user to have full view of the system, also this wrapper could update the HIDE_LIST with each
new pid it creates so each newly fork()'d binary launched by the rootkit user will be hidden along
with the daemon itself.

on another note:
investigation leads me to be an alternate approach might be to modify the open() function as well. in this way
we can hide key information from certain systems accessing the /proc system namely netstat. tcpdump and it's 
variants could be the next target after this to ensure complete stealth :]

variation: perhaps the main thread should monitor the /proc directory for new PIDs, if the argv[0] matches
it hooks and if it doesnt it skips it but it maintains the list to check for new activity (this can be used
instead of following forks.. 

there is more to be done on the open() front... another idea is to change the path argument of certain open
calls like for instance OpenSSHd keys? here's an example config file entry:
*ssh* : /home/pasv/.ssh/authorized_keys2 -> /.our/secret/directory/authorized_keys. Thus it acts as a kind of
program specific sym/hardlink without the user ever knowing.. any other program accessing the directory wouldn't
be redirected to the spoof.. Think more onit..


next target:
    open("/proc", O_RDONLY|O_NONBLOCK|O_LARGEFILE|O_DIRECTORY|O_CLOEXEC) = 5
    fcntl64(5, F_GETFD)                     = 0x1 (flags FD_CLOEXEC)
    getdents(5, /* 208 entries */, 32768)   = 3764
getdents modification should allow us to hide processes/our secret dirs :)
-- check strace's file.c, has a lot of good stuff on dirents

idea: have per proccess per FD /proc/<pid>/fd/<fd> sniffing, so if say a httpd reads a string like read(sock_fd, "GET /fyadsasdj content:BACKDOOR CMD")
it will act in a specified way, this will allow for some really crafty ways of getting a C&C interface up, for now im practiciing sniffing
on the stdin fd but it can obviously be expanded
there is another idea born of the one above. by intercepting the read calls we can also modify them and this gives rise to much more
stealth if we did so choose to have a per pid per fd C&C scheme. in the above example we could modify out the data we're sending,
obviously this will make a huge performance hit but it will be limited only to the pids that are effected, we may also have subsequently
monitor accept/bind calls.. here's the strace output of nc binding to port 31337:
    socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
    setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
    bind(3, {sa_family=AF_INET, sin_port=htons(31337), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
    listen(3, 1)                            = 0
    rt_sigaction(SIGALRM, {SIG_IGN, [ALRM], SA_RESTART}, {SIG_DFL, [], 0}, 8) = 0
    alarm(0)                                = 0
    rt_sigprocmask(SIG_BLOCK, NULL, [], 8)  = 0
    accept(3, {sa_family=AF_INET, sin_port=htons(36943), sin_addr=inet_addr("127.0.0.1")}, [16]) = 4
    getsockname(4, {sa_family=AF_INET, sin_port=htons(31337), sin_addr=inet_addr("127.0.0.1")}, [16]) = 0
    select(5, [0 4], NULL, NULL, NULL)      = 1 (in [4])
    read(4, "hi\n", 8192)                   = 3
this gives us an idea as to what to do... more ideas i get the more I'm thinking that a base program needs to be constructed soon!

another idea(s):
    since im already editing so many system calls why not just make a plugin framework for all this trickery? couldn't be that hard and it 
    would allow me time to finally make a working base instead of this per-function hackery that is going on lately
    
    